# Задача про последовательность "0" и "1"

###  ЗАДАЧА

Дана последовательность  "0" и "1". Рассматриваются все последовательности, получаемые из данной удалением не более одного "0". В таких последовательностях рассматриваются подстроки состоящие из одних "1". Найти максимальную длины такое подпоследовательности.

###  СОСТОЯНИЯ АВТОМАТА

Посмотрим FSM (конечный автомат). У FSM есть набор состояний A, B, C, ... В каждый момент времени автомат находится в определенном состоянии. В каждый момент времени FSM считывает следующий бит из последовательности и переходит в другой состояние (возможно, то же самое). В начальный момент времени автомат находит в определенном состоянии.

Таблица переходом автомата задана следующим образом:

(1) Если FSM считывает "1", то переходит в состояние A (независимо от пред. состояния)

(2) Если FSM считывает "0" и текущие состояние A, то переходит в состояние B

(3) Если FSM считывает "0" и текущее состояние B, то переходит в состояние C

(4) Если FSM считывает "0" и текущее состояние C, то остается в этом состоянии (no transition)


Неформально говоря,

- если в начал цикла автомат находится в состоянии A, значит предыдущие бит был `...1`;
- если в состоянии B, значит предыдущие биты были `10..`;
- если в состоянии C, то предыдущие биты были `..00` или это начало строки.

Начальное состояние C. Можно было бы ввести отдельное состояние D, но с точки зрения логики и переходом оно идентично C, поэтому нет смысла вводит новое состояние.

### СЧЕТЧИК `count`

Теперь, введем новый счетчик `count`. Будет вычислять его по след правилам:

(1) Если считываем "1", то `count++`

(2) Если считываем "0" и текущее состояние A, то `count := 0`

(3) Без изменений во всех остальных случаях

Легко видеть, что в каждый момент времени `count` дает длину последней непрерывной послдовательности "1". То есть если текущее наблюдаемое значение "1", то count  дает блину максимальной непрерывной послед "1" которая заканчивается на этой "1". Если текущий бит "0", то `count == 0`.

### СЧЕТЧИК `prev_count`

Теперь введем второй счетчик `prev_count`, которые вычисляем по след правилам:

(1) Начальное значение `prev_count = 0`

(2) Если наблюдаем "0" и состояние A, то `prev_count = count`

(3) Если наблюдаем "0" и состояние B, то `prev_count = 0`

(4) Без изменений во всех остальных случаях

Легко видеть, что `prev_count` дает длину максимальной предудущей последовательности "1" которая может быть соединена с текущей путем удаления не более одного нолика. Если соединить нельзя, то `prev_count = 0`. Вычисление (обновление) `prev_count` происходит когда мы переключаемся с "1"-к на "0"-ки. Значение count записывается в prev_count. Если дальше идет второй нолик, то значение `prev_count := 0` так как уже нельзя сджойнить.

### ВЫЧИСЛЕНИЕ ДЛИНЫ МАКСИМАЛЬНОЙ ПОДПОСЛЕДОВАТЕЛЬНОСТИ

Теперь вычислим длину максимальной подпоследовательности "1" которая может быть получена из исходной путем удаления не более одного нолика. Изначально положим `max = 0`. Это значени будет обновлять на каждой итерации  по след правилу:

(1) Если наблюдаем "1", то вычислим `count + prev_count`. Если это значение превосходит текущий максимум, обновим этот максимум max.

(2) Без изменений в остальных случаях


###  КОД

Таким образом получаем алгоритм

```java
int computeMaxSequence(int[] a) {
    // init
    State state = State.C;
    int count = 0;
    int prev_count = 0;
    int max = 0;

    // read each bit in turn, update FSM state and counts
    for (int i = 0; i < a.length; i++) {
        if (a[i] == 1) {    // ..1
            count++;

            if (count + prev_count > max) {
                max = count + prev_count;
            }

            state = State.A;

            // a[i] == 0 from here
        } else if (state == State.A) {  // ..10
            prev_count = count;
            count = 0;
            state = State.B;
        } else if (state == State.B) {   // ..00
            prev_count = 0;
            state = State.C;
        }
        // other cases: no action
    }

    return max;
}

// FSM states
enum State {
    A, // seen ...1 before
    B, // seen ..10 before
    C  // seen ..00 before or start of sequence
}
```

https://github.com/arkadius2006/algorithms/blob/master/src/main/java/com/tinkoff/MaxSequence.java


###  ФИНАЛЬНЫЕ ЗАМЕЧАНИЯ

(1) Особенностью алгоритма являеся то что он однопроходный. То есть мы не обращаемся к a[i-1] или a[i+1]. А на каждой итерации считываем только очередное значение и по одному разу. Чисто практически, например, такой подход выгоднее когда мы не знаем всю последовательность сразу и/или массив `a[]` не помещается в память.

(2) В приведенном алгоритме max обновляется на каждой "1" чтобы содержать актуальной на текущий момент значение max. На самом деле, max можно обновлять только по завершению очередной последовательности "1", то есть когда мы считываем = "0" после после последовательности "1" (состояние A), а также в конце последовательности. Это вариант алгоритма. В нем лишний раз не обновляется max до тех пор пока не дойдем до конца текущей последовательности "1".

(3) Вместо `enum {A, B, C}` можно было использовать просто значения 0, 1, 2 (ввести переменную int). Это не принципиальный момент. Я использовать enum для большей читабельности кода (под капотом это и есть int который принимает значения 0, 1, 2)
